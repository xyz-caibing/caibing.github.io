{"title":"买了个菜饼","description":"记录我在成为一名架构师路上的学习过程。","language":"","link":"//caibing.github.io","pubDate":"Fri, 18 Sep 2020 08:23:00 GMT","lastBuildDate":"Mon, 28 Sep 2020 07:49:11 GMT","generator":"hexo-generator-json-feed","webMaster":"菜饼","items":[{"title":"Docker 命令集","link":"//caibing.github.io/2020/09/18/docker-command/","description":"获取镜像 从Docker镜像仓库获取镜像的命令是docker pull。其命令格式为：12docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] *注意 这里的仓库名是两段式名称，即&lt;用户名&gt;/&lt;软件名&gt;。对于Docker Hub，如果不给出用户名，则默认为library，也就是官方镜像。 列出镜像 可以通过 docker images [ls] 列出已经下载的所有顶层镜像。其命令格式为： 1234567891011121314docker images [选项] [仓库名[:标签]]选项： -a, --all 希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。 --digests 摘要 -f, --filter value 根据提供的条件过滤输出 - dangling =(true|false) 显示*[虚悬镜像]:详细解释在下方 - label =&lt;key&gt; or label=&lt;key&gt;=&lt;value&gt; 如果镜像构建时，定义了label，可以通过label来过滤 - before =(&lt;image-name&gt;[:tag]|&lt;image-id&gt;|&lt;image@digest&gt;) 希望看到某个镜像之后建立的镜像 - since =(&lt;image-name&gt;[:tag]|&lt;image-id&gt;|&lt;image@digest&gt;) 希望查看某个位置之前的镜像 --format string 以特定格式显示 --help --no-trunc 不要截断输出 -q, --quiet 仅显示IMAGE ID，‘注意可以和-f搭配组合以完成很强大的功能，看到过滤器后，可以多注意一下它们的用法’ 镜像体积：显示的是镜像下载到本地后，展开后的各层所占空间的总和。需注意镜像体积总和并非是所有镜像实际硬盘消耗，因为docker镜像是多层存储结构，并可以继承、复用相同的基础镜像。可以用下面的命令 1docker images ls [仓库名[:标签]] 虚悬镜像（dangling image）：镜像原本是有镜像名和标签的，如ubuntu:16.04，随着官方镜像维护，发布新版本后，重新docker pull ubuntu:16.04时，这个镜像名被转移到了新下载的镜像身上，而旧的镜像上这个名称则被取消，从而成为了.这类无标签镜像也被称为 虚悬镜像。可以用下面的命令 1docker images ls -f dangling=true 一般来说虚悬镜像已经失去存在必要，可以删除，可以用下面的命令 1docker images prune 中间层镜像：为了加速镜像构建、重复利用资源，docker会利用中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。可以用下面的命令 1docker images ls -a 列出部分镜像 12345docker images ls [仓库名[:标签]]docker images ls -f since=仓库名:标签docker images ls -f label=com.example.version=0.1 以特定格式显示，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。 123docker images ls --format \"&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;\"docker images ls --format \"table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;\"","pubDate":"Fri, 18 Sep 2020 08:23:00 GMT","guid":"//caibing.github.io/2020/09/18/docker-command/","category":"docker"},{"title":"lt takes a village","link":"//caibing.github.io/2020/09/12/village-2020/","description":"前言在今天的公司文化里，非常强调团队协作，我们要面对的工作非常复杂，几乎没有什么人能完全独当一面。同样，回到家里，养孩子也是个复杂的系统工程，聪明的女性，要学会建立一个强有力的支持系统。通常，妈妈们，不管是职场妈妈还是全职妈妈，会理所当然的认为，教育孩子的主要的职责是自己的。但即使你觉得自己负主要职责，妈妈不是，也不应该是唯一的负责人。就像在公司里，想要做成事，一定要一个团队来一起做一样。我们在家里教育孩子，也需要利用一个团队。 谁会是你的队友？ 一类是孩子的爸爸和亲戚、长辈； 第二类是友邻和朋友 待续…","pubDate":"Sat, 12 Sep 2020 00:51:00 GMT","guid":"//caibing.github.io/2020/09/12/village-2020/","category":"培养面向未来的孩子"},{"title":"面向对象的设计 总结","link":"//caibing.github.io/2020/09/11/oop-summary-2020/","description":"代码建模就是把业务抽象成事务（类、抽象类）和行为（接口）的过程。 面向对象的设计原则 对接口编程，不要对实现编程 使用对象之间的组合，减少对继承的使用 抽象用于不同的事务，而接口用于事物的行为 结论：代码建模过程就是“面向对象设计过程”的具体实现方式 设计模式的设计原则123456开闭原则：对扩展开放，对修改关闭依赖倒置：对接口编程，依赖于抽象而不依赖于具体接口隔离：使用多个接口，而不是对一个接口编程，去依赖降低耦合最少知道：减少内部依赖，尽可能的独立合成复用：多个独立的实体合成聚合，而不是使用继承里氏代换：超类出现的地方，派生类都可以出现","pubDate":"Fri, 11 Sep 2020 08:42:00 GMT","guid":"//caibing.github.io/2020/09/11/oop-summary-2020/","category":"面向对象总结,summary"},{"title":"2020年的目标","link":"//caibing.github.io/2020/09/10/my-target-2020/","description":"完善自己的技术栈： docker &amp; k8s kafka 系统架构学习： 学习掌握php设计模式应用 业务架构学习： 设计用户体系 设计购物车体系 设计营销体系 设计交易中心 待续…","pubDate":"Thu, 10 Sep 2020 05:26:00 GMT","guid":"//caibing.github.io/2020/09/10/my-target-2020/","category":"目标,target"},{"title":"Hello World","link":"//caibing.github.io/2020/09/09/hello-world/","description":"在Winiex的推荐和帮助下，这个octopress博客终于搭建起来了。 折腾了两天多，在github page上看到自己的博客加载下来时，突然有种错综复杂的恍惚感。是的，它不是qq空间，不是新浪博客，不是豆瓣小站，也不是贴吧。它更像是属于自己的一块小小的领地，因而我满足于这种归属感。我愿在上面安静劳作。 一个农民，通过自身努力终于分到了一块地，不再需要在地主的土地上创造流量价值时，于是翻身作主的他可以宣告说：Hello World。当然这个农民确切来说是个码农。 感谢Zespia提供的slash主题。我很喜欢这种色调。","pubDate":"Wed, 09 Sep 2020 12:39:00 GMT","guid":"//caibing.github.io/2020/09/09/hello-world/","category":"杂谈,octopress"}]}